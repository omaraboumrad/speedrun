<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Speedrun</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Exo+2:wght@300;400;600;700&display=swap');

        body {
            margin: 0;
            padding: 0;
            background: radial-gradient(ellipse at center, #1a1a2e 0%, #16213e 40%, #0f3460 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Exo 2', sans-serif;
            overflow: hidden;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background:
                radial-gradient(circle at 20% 80%, rgba(70, 130, 220, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(50, 100, 200, 0.15) 0%, transparent 50%),
                radial-gradient(circle at 40% 40%, rgba(120, 180, 255, 0.1) 0%, transparent 50%);
            pointer-events: none;
            z-index: -1;
        }

        canvas {
            border: 3px solid #4a5568;
            border-radius: 12px;
            box-shadow:
                0 20px 40px rgba(0, 0, 0, 0.5),
                inset 0 0 30px rgba(255, 255, 255, 0.1);
            background: linear-gradient(180deg,
                #4a90e2 0%,
                #357abd 30%,
                #2c5e9c 60%,
                #1e4080 80%,
                #4facfe 100%);
        }

        .instructions {
            position: absolute;
            top: 30px;
            left: 50%;
            transform: translateX(-50%);
            color: #e2e8f0;
            font-size: 16px;
            font-weight: 400;
            text-align: center;
            background: rgba(26, 32, 46, 0.8);
            padding: 12px 24px;
            border-radius: 25px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
            font-family: 'Exo 2', sans-serif;
            letter-spacing: 0.5px;
        }

        .instructions::before {
            content: '';
            position: absolute;
            top: -1px;
            left: -1px;
            right: -1px;
            bottom: -1px;
            background: linear-gradient(45deg, #4a90e2, #357abd, #2c5e9c, #4a90e2);
            border-radius: 25px;
            z-index: -1;
            opacity: 0.3;
        }
    </style>
</head>
<body>
    <div class="instructions">
        Arrow keys to move | SPACE to jump (double jump available)! | R to restart speedrun
    </div>
    <canvas id="gameCanvas" width="800" height="400"></canvas>
    
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Game variables
        const gravity = 0.8;
        const jumpPower = -15;
        const moveSpeed = 5;

        // Delta time tracking for frame-independent movement
        let lastFrameTime = performance.now();
        const targetFPS = 60;
        const targetFrameTime = 1000 / targetFPS;
        
        // Player object
        const player = {
            x: 50,
            y: 300,
            width: 20,
            height: 20,
            velocityX: 0,
            velocityY: 0,
            onGround: false,
            jumpCount: 0,
            maxJumps: 2,
            color: '#FF6B6B'
        };
        
        // Level data
        const levels = {
            1: {
                name: "First Steps",
                platforms: [
                    // Tutorial level - simple jumps and single double jump
                    { x: 0, y: 350, width: 150, height: 50 },
                    { x: 200, y: 350, width: 100, height: 20 },
                    { x: 350, y: 350, width: 100, height: 20 },
                    { x: 500, y: 350, width: 150, height: 50 },
                    { x: 700, y: 300, width: 100, height: 20 }
                ],
                goal: { x: 720, y: 270, width: 30, height: 30, color: '#FFD700' }
            },
            2: {
                name: "Double Trouble",
                platforms: [
                    // Introduction to double jumping
                    { x: 0, y: 350, width: 120, height: 50 },
                    { x: 200, y: 300, width: 80, height: 20 },
                    { x: 380, y: 250, width: 80, height: 20 },
                    { x: 560, y: 300, width: 80, height: 20 },
                    { x: 720, y: 200, width: 80, height: 20 }
                ],
                goal: { x: 730, y: 170, width: 30, height: 30, color: '#FFD700' }
            },
            3: {
                name: "Gap Master",
                platforms: [
                    // Wider gaps requiring double jumps
                    { x: 0, y: 350, width: 100, height: 50 },
                    { x: 220, y: 280, width: 60, height: 20 },
                    { x: 400, y: 320, width: 60, height: 20 },
                    { x: 580, y: 260, width: 60, height: 20 },
                    { x: 700, y: 180, width: 100, height: 20 }
                ],
                goal: { x: 720, y: 150, width: 30, height: 30, color: '#FFD700' }
            },
            4: {
                name: "Vertical Maze",
                platforms: [
                    // Vertical climbing challenge
                    { x: 0, y: 350, width: 100, height: 50 },
                    { x: 150, y: 300, width: 50, height: 20 },
                    { x: 250, y: 250, width: 50, height: 20 },
                    { x: 150, y: 200, width: 50, height: 20 },
                    { x: 250, y: 150, width: 50, height: 20 },
                    { x: 350, y: 100, width: 50, height: 20 },
                    { x: 450, y: 150, width: 50, height: 20 },
                    { x: 550, y: 100, width: 50, height: 20 },
                    { x: 650, y: 150, width: 150, height: 20 }
                ],
                goal: { x: 700, y: 120, width: 30, height: 30, color: '#FFD700' }
            },
            5: {
                name: "Obstacle Course",
                platforms: [
                    // Obstacles and precision platforming
                    { x: 0, y: 350, width: 80, height: 50 },
                    { x: 140, y: 280, width: 40, height: 20 },
                    { x: 240, y: 300, width: 40, height: 20 },
                    { x: 340, y: 250, width: 40, height: 20 },
                    { x: 440, y: 200, width: 40, height: 20 },
                    { x: 540, y: 250, width: 40, height: 20 },
                    { x: 640, y: 180, width: 40, height: 20 },
                    { x: 720, y: 120, width: 80, height: 20 },

                    // Obstacles
                    { x: 100, y: 250, width: 20, height: 100 },
                    { x: 200, y: 200, width: 20, height: 100 },
                    { x: 380, y: 150, width: 20, height: 100 },
                    { x: 500, y: 150, width: 20, height: 100 },
                    { x: 600, y: 100, width: 20, height: 80 }
                ],
                goal: { x: 730, y: 90, width: 30, height: 30, color: '#FFD700' }
            },
            6: {
                name: "Narrow Escape",
                platforms: [
                    // Very narrow platforms
                    { x: 0, y: 350, width: 60, height: 50 },
                    { x: 120, y: 280, width: 30, height: 20 },
                    { x: 200, y: 220, width: 30, height: 20 },
                    { x: 280, y: 280, width: 30, height: 20 },
                    { x: 360, y: 200, width: 30, height: 20 },
                    { x: 440, y: 260, width: 30, height: 20 },
                    { x: 520, y: 180, width: 30, height: 20 },
                    { x: 600, y: 240, width: 30, height: 20 },
                    { x: 680, y: 160, width: 30, height: 20 },
                    { x: 750, y: 100, width: 50, height: 20 }
                ],
                goal: { x: 760, y: 70, width: 30, height: 30, color: '#FFD700' }
            },
            7: {
                name: "The Gauntlet",
                platforms: [
                    // Mixed challenges - long jumps and precise landing
                    { x: 0, y: 350, width: 80, height: 50 },
                    { x: 160, y: 250, width: 30, height: 20 },
                    { x: 280, y: 200, width: 40, height: 20 },
                    { x: 420, y: 280, width: 30, height: 20 },
                    { x: 520, y: 150, width: 30, height: 20 },
                    { x: 620, y: 220, width: 30, height: 20 },
                    { x: 720, y: 100, width: 80, height: 20 },

                    // Moving obstacles simulation with multiple heights
                    { x: 120, y: 200, width: 20, height: 150 },
                    { x: 240, y: 120, width: 20, height: 80 },
                    { x: 380, y: 180, width: 20, height: 100 },
                    { x: 480, y: 100, width: 20, height: 50 },
                    { x: 580, y: 120, width: 20, height: 100 },
                    { x: 680, y: 80, width: 20, height: 20 }
                ],
                goal: { x: 730, y: 70, width: 30, height: 30, color: '#FFD700' }
            },
            8: {
                name: "Precision Master",
                platforms: [
                    // Extremely precise jumps required
                    { x: 0, y: 350, width: 60, height: 50 },
                    { x: 140, y: 270, width: 25, height: 20 },
                    { x: 240, y: 200, width: 25, height: 20 },
                    { x: 340, y: 270, width: 25, height: 20 },
                    { x: 440, y: 180, width: 25, height: 20 },
                    { x: 540, y: 250, width: 25, height: 20 },
                    { x: 640, y: 160, width: 25, height: 20 },
                    { x: 720, y: 220, width: 25, height: 20 },
                    { x: 760, y: 120, width: 40, height: 20 }
                ],
                goal: { x: 770, y: 90, width: 30, height: 30, color: '#FFD700' }
            },
            9: {
                name: "Sky Bridge",
                platforms: [
                    // High altitude challenge with long gaps
                    { x: 0, y: 350, width: 100, height: 50 },
                    { x: 200, y: 200, width: 50, height: 20 },
                    { x: 350, y: 150, width: 40, height: 20 },
                    { x: 500, y: 180, width: 40, height: 20 },
                    { x: 650, y: 120, width: 50, height: 20 },
                    { x: 750, y: 80, width: 50, height: 20 },

                    // Support pillars (obstacles)
                    { x: 150, y: 300, width: 30, height: 20 },
                    { x: 300, y: 250, width: 30, height: 20 },
                    { x: 450, y: 280, width: 30, height: 20 },
                    { x: 600, y: 220, width: 30, height: 20 }
                ],
                goal: { x: 760, y: 50, width: 30, height: 30, color: '#FFD700' }
            },
            10: {
                name: "The Final Test",
                platforms: [
                    // Ultimate challenge combining all skills
                    { x: 0, y: 350, width: 80, height: 50 },
                    { x: 140, y: 280, width: 20, height: 20 },
                    { x: 220, y: 200, width: 30, height: 20 },
                    { x: 320, y: 260, width: 20, height: 20 },
                    { x: 400, y: 160, width: 25, height: 20 },
                    { x: 500, y: 240, width: 20, height: 20 },
                    { x: 580, y: 140, width: 25, height: 20 },
                    { x: 660, y: 200, width: 20, height: 20 },
                    { x: 720, y: 100, width: 30, height: 20 },
                    { x: 770, y: 60, width: 30, height: 20 },

                    // Final obstacles
                    { x: 100, y: 250, width: 15, height: 100 },
                    { x: 180, y: 150, width: 15, height: 50 },
                    { x: 280, y: 160, width: 15, height: 100 },
                    { x: 360, y: 120, width: 15, height: 40 },
                    { x: 460, y: 120, width: 15, height: 40 },
                    { x: 540, y: 100, width: 15, height: 40 },
                    { x: 620, y: 100, width: 15, height: 100 },
                    { x: 680, y: 80, width: 15, height: 20 }
                ],
                goal: { x: 775, y: 30, width: 30, height: 30, color: '#FFD700' }
            }
        };
        
        // Current level state
        let currentLevel = 1;
        let platforms = levels[currentLevel].platforms;
        let goal = levels[currentLevel].goal;
        
        // Game state
        let gameWon = false;
        let gameLost = false;
        let speedrunStartTime = null;
        let speedrunCompleted = false;
        let completionTime = null;
        let autoAdvanceTimeout = null;
        let autoRestartTimeout = null;

        // Input state
        const keys = {
            left: false,
            right: false
        };

        function drawBackground() {
            // Create animated gradient background
            const time = Date.now() * 0.001;

            // Main gradient - all blue tones
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, `hsl(${210 + Math.sin(time * 0.5) * 10}, 70%, ${65 + Math.sin(time * 0.3) * 10}%)`);
            gradient.addColorStop(0.3, `hsl(${220 + Math.cos(time * 0.4) * 8}, 65%, ${55 + Math.cos(time * 0.2) * 8}%)`);
            gradient.addColorStop(0.6, `hsl(${200 + Math.sin(time * 0.6) * 12}, 75%, ${50 + Math.sin(time * 0.4) * 12}%)`);
            gradient.addColorStop(0.8, `hsl(${190 + Math.cos(time * 0.3) * 8}, 80%, ${45 + Math.cos(time * 0.5) * 10}%)`);
            gradient.addColorStop(1, `hsl(${180 + Math.sin(time * 0.2) * 15}, 85%, ${60 + Math.sin(time * 0.6) * 15}%)`);

            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Add floating particles/stars
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            for (let i = 0; i < 30; i++) {
                const x = (i * 47 + Math.sin(time + i) * 20) % canvas.width;
                const y = (i * 31 + Math.cos(time * 0.8 + i) * 15) % canvas.height;
                const size = 1 + Math.sin(time * 2 + i) * 0.5;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }

            // Add atmospheric clouds
            ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
            for (let i = 0; i < 5; i++) {
                const x = (i * 160 + Math.sin(time * 0.2 + i) * 30) % (canvas.width + 100);
                const y = 50 + i * 60 + Math.cos(time * 0.15 + i) * 20;
                const width = 80 + Math.sin(time * 0.3 + i) * 20;
                const height = 40 + Math.cos(time * 0.25 + i) * 10;

                ctx.beginPath();
                ctx.ellipse(x, y, width, height, 0, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        function drawPlayer() {
            const time = Date.now() * 0.005;

            // Player body with gradient and glow
            const gradient = ctx.createRadialGradient(
                player.x + player.width/2, player.y + player.height/2, 0,
                player.x + player.width/2, player.y + player.height/2, player.width
            );
            gradient.addColorStop(0, '#ff6b9d');
            gradient.addColorStop(0.7, '#ff6b6b');
            gradient.addColorStop(1, '#d63384');

            // Add glow effect
            ctx.shadowColor = '#ff6b9d';
            ctx.shadowBlur = 15;
            ctx.fillStyle = gradient;
            ctx.fillRect(player.x - 1, player.y - 1, player.width + 2, player.height + 2);

            // Reset shadow
            ctx.shadowBlur = 0;

            // Body highlight
            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.fillRect(player.x + 2, player.y + 2, player.width - 4, 3);

            // Animated eyes
            const eyeOffset = Math.sin(time) * 0.5;
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(player.x + 6, player.y + 6 + eyeOffset, 3, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(player.x + 14, player.y + 6 + eyeOffset, 3, 0, Math.PI * 2);
            ctx.fill();

            // Pupils
            ctx.fillStyle = '#1a1a2e';
            ctx.beginPath();
            ctx.arc(player.x + 6.5, player.y + 6.5 + eyeOffset, 1.5, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(player.x + 14.5, player.y + 6.5 + eyeOffset, 1.5, 0, Math.PI * 2);
            ctx.fill();

            // Eye shine
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.beginPath();
            ctx.arc(player.x + 6.5, player.y + 5.5 + eyeOffset, 0.5, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(player.x + 14.5, player.y + 5.5 + eyeOffset, 0.5, 0, Math.PI * 2);
            ctx.fill();

            // Trail effect when moving fast
            if (Math.abs(player.velocityX) > 3) {
                ctx.fillStyle = 'rgba(255, 107, 157, 0.3)';
                for (let i = 1; i <= 3; i++) {
                    const trailX = player.x - (player.velocityX > 0 ? i * 3 : -i * 3);
                    ctx.fillRect(trailX, player.y, player.width, player.height);
                }
            }
        }
        
        function drawPlatforms() {
            platforms.forEach(platform => {
                // Platform gradient
                const gradient = ctx.createLinearGradient(
                    platform.x, platform.y,
                    platform.x, platform.y + platform.height
                );
                gradient.addColorStop(0, '#4a90e2');
                gradient.addColorStop(0.3, '#357abd');
                gradient.addColorStop(0.7, '#2c5e9c');
                gradient.addColorStop(1, '#1e4080');

                // Platform shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.fillRect(platform.x + 2, platform.y + 2, platform.width, platform.height);

                // Main platform
                ctx.fillStyle = gradient;
                ctx.fillRect(platform.x, platform.y, platform.width, platform.height);

                // Platform highlight
                ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                ctx.fillRect(platform.x, platform.y, platform.width, 2);

                // Platform edge glow
                ctx.strokeStyle = 'rgba(116, 185, 255, 0.6)';
                ctx.lineWidth = 1;
                ctx.strokeRect(platform.x, platform.y, platform.width, platform.height);
            });
        }
        
        function drawGoal() {
            const time = Date.now() * 0.008;
            const centerX = goal.x + goal.width / 2;
            const centerY = goal.y + goal.height / 2;

            // Rotating glow effect
            ctx.save();
            ctx.translate(centerX, centerY);
            ctx.rotate(time);

            // Outer glow
            const glowGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, 40);
            glowGradient.addColorStop(0, 'rgba(255, 215, 0, 0.8)');
            glowGradient.addColorStop(0.5, 'rgba(255, 165, 0, 0.4)');
            glowGradient.addColorStop(1, 'rgba(255, 165, 0, 0)');
            ctx.fillStyle = glowGradient;
            ctx.fillRect(-40, -40, 80, 80);

            ctx.restore();

            // Goal body gradient
            const gradient = ctx.createRadialGradient(
                centerX, centerY, 0,
                centerX, centerY, goal.width/2
            );
            gradient.addColorStop(0, '#ffd700');
            gradient.addColorStop(0.7, '#ffb347');
            gradient.addColorStop(1, '#ff8c00');

            ctx.fillStyle = gradient;
            ctx.fillRect(goal.x, goal.y, goal.width, goal.height);

            // Animated star effect
            ctx.save();
            ctx.translate(centerX, centerY);

            for (let i = 0; i < 8; i++) {
                ctx.save();
                ctx.rotate((time + i * Math.PI / 4) * (i % 2 === 0 ? 1 : -1));

                const starGradient = ctx.createLinearGradient(0, -12, 0, 12);
                starGradient.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
                starGradient.addColorStop(0.5, 'rgba(255, 215, 0, 0.8)');
                starGradient.addColorStop(1, 'rgba(255, 165, 0, 0.6)');

                ctx.fillStyle = starGradient;
                ctx.fillRect(-1, -12, 2, 24);
                ctx.fillRect(-12, -1, 24, 2);
                ctx.restore();
            }

            ctx.restore();

            // Pulsing border
            const pulseIntensity = 0.5 + 0.5 * Math.sin(time * 3);
            ctx.strokeStyle = `rgba(255, 255, 255, ${pulseIntensity})`;
            ctx.lineWidth = 2;
            ctx.strokeRect(goal.x - 1, goal.y - 1, goal.width + 2, goal.height + 2);
        }
        
        function checkCollisions() {
            player.onGround = false;

            platforms.forEach(platform => {
                // Check if player is colliding with platform
                if (player.x < platform.x + platform.width &&
                    player.x + player.width > platform.x &&
                    player.y < platform.y + platform.height &&
                    player.y + player.height > platform.y) {

                    // Calculate overlap amounts
                    const overlapLeft = (player.x + player.width) - platform.x;
                    const overlapRight = (platform.x + platform.width) - player.x;
                    const overlapTop = (player.y + player.height) - platform.y;
                    const overlapBottom = (platform.y + platform.height) - player.y;

                    // Find the smallest overlap to determine collision direction
                    const minOverlap = Math.min(overlapLeft, overlapRight, overlapTop, overlapBottom);

                    if (minOverlap === overlapTop && player.velocityY > 0) {
                        // Landing on top
                        player.y = platform.y - player.height;
                        player.velocityY = 0;
                        player.onGround = true;
                        player.jumpCount = 0;
                    } else if (minOverlap === overlapBottom && player.velocityY < 0) {
                        // Hitting from below
                        player.y = platform.y + platform.height;
                        player.velocityY = 0;
                    } else if (minOverlap === overlapLeft) {
                        // Hitting from the left (player running into platform)
                        player.x = platform.x - player.width;
                        player.velocityX = 0;
                    } else if (minOverlap === overlapRight) {
                        // Hitting from the right
                        player.x = platform.x + platform.width;
                        player.velocityX = 0;
                    }
                }
            });

            // Check goal collision
            if (player.x < goal.x + goal.width &&
                player.x + player.width > goal.x &&
                player.y < goal.y + goal.height &&
                player.y + player.height > goal.y) {
                gameWon = true;

                // Check if this completes the speedrun
                if (currentLevel === 10 && !speedrunCompleted) {
                    speedrunCompleted = true;
                    completionTime = Date.now() - speedrunStartTime;
                } else if (currentLevel < 10) {
                    // Auto-advance to next level for levels 1-9
                    autoAdvanceLevel();
                }
            }

            // Check if player fell off screen
            if (player.y > canvas.height && !gameLost) {
                gameLost = true;
                autoRestartLevel();
            }
        }
        
        function updatePlayer(deltaTime) {
            if (gameWon || gameLost) return;

            // Start speedrun timer on first movement
            if (!speedrunStartTime && !speedrunCompleted && (keys.left || keys.right)) {
                speedrunStartTime = Date.now();
            }

            // Handle horizontal input and acceleration
            if (keys.left) {
                player.velocityX -= 0.8 * deltaTime;
            }
            if (keys.right) {
                player.velocityX += 0.8 * deltaTime;
            }

            // Apply horizontal friction when on ground and no input
            if (player.onGround && !keys.left && !keys.right) {
                player.velocityX *= Math.pow(0.85, deltaTime); // Ground friction
            } else if (!player.onGround) {
                player.velocityX *= Math.pow(0.98, deltaTime); // Air resistance (minimal)
            }

            // Cap horizontal velocity
            const maxHorizontalSpeed = 8;
            if (player.velocityX > maxHorizontalSpeed) player.velocityX = maxHorizontalSpeed;
            if (player.velocityX < -maxHorizontalSpeed) player.velocityX = -maxHorizontalSpeed;

            // Stop very small velocities to prevent endless drift
            if (Math.abs(player.velocityX) < 0.1) player.velocityX = 0;

            // Apply horizontal velocity
            player.x += player.velocityX * deltaTime;

            // Keep player within screen bounds
            if (player.x < 0) {
                player.x = 0;
                player.velocityX = 0;
            }
            if (player.x + player.width > canvas.width) {
                player.x = canvas.width - player.width;
                player.velocityX = 0;
            }

            // Apply gravity
            player.velocityY += gravity * deltaTime;
            player.y += player.velocityY * deltaTime;

            // Check collisions
            checkCollisions();
        }
        
        function jump() {
            if (!gameWon && !gameLost && (player.onGround || player.jumpCount < player.maxJumps)) {
                // Jump up (ground jump or double jump)
                player.velocityY = jumpPower;
                player.onGround = false;
                player.jumpCount++;
            }
        }
        
        function drawUI() {
            // Draw level indicator with glow
            ctx.save();
            ctx.shadowColor = '#4a90e2';
            ctx.shadowBlur = 10;
            ctx.fillStyle = '#e2e8f0';
            ctx.font = 'bold 18px "Orbitron", monospace';
            ctx.textAlign = 'left';
            ctx.fillText(`LEVEL ${currentLevel}`, 15, 25);
            ctx.restore();

            // Draw level name
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.font = '14px "Exo 2", sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText(levels[currentLevel].name, 15, 45);

            // Draw speedrun timer (top right)
            const currentTime = getCurrentTime();
            const timeText = formatTime(currentTime);

            ctx.save();
            ctx.shadowColor = speedrunCompleted ? '#00ff00' : '#4a90e2';
            ctx.shadowBlur = 8;
            ctx.fillStyle = speedrunCompleted ? '#00ff88' : '#e2e8f0';
            ctx.font = 'bold 24px "Orbitron", monospace';
            ctx.textAlign = 'right';
            ctx.fillText(timeText, canvas.width - 15, 35);
            ctx.restore();

            // Timer label
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.font = '12px "Exo 2", sans-serif';
            ctx.textAlign = 'right';
            ctx.fillText(speedrunCompleted ? 'FINAL TIME' : 'TIME', canvas.width - 15, 50);



        }
        
        function drawGameState() {
            if (speedrunCompleted) {
                // Speedrun completion screen
                ctx.fillStyle = 'rgba(0, 255, 0, 0.9)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                ctx.save();
                ctx.shadowColor = '#00ff00';
                ctx.shadowBlur = 20;
                ctx.fillStyle = 'white';
                ctx.font = 'bold 48px "Orbitron", monospace';
                ctx.textAlign = 'center';
                ctx.fillText('SPEEDRUN COMPLETE!', canvas.width / 2, canvas.height / 2 - 40);
                ctx.restore();

                ctx.fillStyle = '#00ff88';
                ctx.font = 'bold 36px "Orbitron", monospace';
                ctx.fillText(formatTime(completionTime), canvas.width / 2, canvas.height / 2 + 20);

                ctx.fillStyle = 'white';
                ctx.font = '20px "Exo 2", sans-serif';
                ctx.fillText('Press R to restart speedrun', canvas.width / 2, canvas.height / 2 + 70);
            } else if (gameWon) {
                // Level completion
                ctx.fillStyle = 'rgba(0, 200, 255, 0.8)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                ctx.fillStyle = 'white';
                ctx.font = 'bold 36px "Orbitron", monospace';
                ctx.textAlign = 'center';
                ctx.fillText(`Level ${currentLevel} Complete!`, canvas.width / 2, canvas.height / 2 - 30);

                // Show current time
                ctx.fillStyle = '#00ff88';
                ctx.font = '24px "Orbitron", monospace';
                ctx.fillText(`Time: ${formatTime(getCurrentTime())}`, canvas.width / 2, canvas.height / 2 + 10);

                // Auto-advance message for levels 1-9
                if (currentLevel < Object.keys(levels).length) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.font = '18px "Exo 2", sans-serif';
                    ctx.fillText('Next level starting in 2 seconds...', canvas.width / 2, canvas.height / 2 + 50);
                }
            }

            if (gameLost) {
                // Death screen
                ctx.fillStyle = 'rgba(255, 50, 50, 0.8)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                ctx.fillStyle = 'white';
                ctx.font = 'bold 36px "Orbitron", monospace';
                ctx.textAlign = 'center';
                ctx.fillText('Level Failed!', canvas.width / 2, canvas.height / 2 - 20);

                ctx.font = '18px "Exo 2", sans-serif';
                ctx.fillText('Restarting level...', canvas.width / 2, canvas.height / 2 + 20);

                ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.font = '14px "Exo 2", sans-serif';
                ctx.fillText('Timer continues running', canvas.width / 2, canvas.height / 2 + 50);
            }
        }
        
        function loadLevel(levelNum) {
            if (levels[levelNum]) {
                currentLevel = levelNum;
                platforms = levels[currentLevel].platforms;
                goal = levels[currentLevel].goal;
                resetPlayer();
            }
        }
        
        function resetPlayer() {
            player.x = 50;
            player.y = 300;
            player.velocityX = 0;
            player.velocityY = 0;
            player.onGround = false;
            player.jumpCount = 0;
        }
        
        function resetCurrentLevel() {
            resetPlayer();
            gameWon = false;
            gameLost = false;
            // Timer continues running
        }

        function resetSpeedrun() {
            // Clear any pending timeouts first to prevent glitches
            if (autoAdvanceTimeout) {
                clearTimeout(autoAdvanceTimeout);
                autoAdvanceTimeout = null;
            }
            if (autoRestartTimeout) {
                clearTimeout(autoRestartTimeout);
                autoRestartTimeout = null;
            }

            currentLevel = 1;
            platforms = levels[currentLevel].platforms;
            goal = levels[currentLevel].goal;
            resetPlayer();
            gameWon = false;
            gameLost = false;
            speedrunStartTime = null;
            speedrunCompleted = false;
            completionTime = null;
        }
        
        function nextLevel() {
            if (currentLevel < Object.keys(levels).length) {
                loadLevel(currentLevel + 1);
                gameWon = false;
                gameLost = false;
            }
        }

        function autoAdvanceLevel() {
            // Called when level is completed - advances to next level after delay
            if (currentLevel < Object.keys(levels).length) {
                // Clear any existing timeout first
                if (autoAdvanceTimeout) {
                    clearTimeout(autoAdvanceTimeout);
                }
                autoAdvanceTimeout = setTimeout(() => {
                    nextLevel();
                    autoAdvanceTimeout = null;
                }, 2000); // 2 second delay
            }
        }

        function autoRestartLevel() {
            // Called when player dies - restarts current level only
            // Clear any existing timeout first
            if (autoRestartTimeout) {
                clearTimeout(autoRestartTimeout);
            }
            autoRestartTimeout = setTimeout(() => {
                resetCurrentLevel();
                autoRestartTimeout = null;
            }, 1500); // Brief delay to show death state
        }

        function formatTime(milliseconds) {
            if (!milliseconds) return "0:00.00";
            const totalSeconds = milliseconds / 1000;
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = Math.floor(totalSeconds % 60);
            const centiseconds = Math.floor((totalSeconds % 1) * 100);
            return `${minutes}:${seconds.toString().padStart(2, '0')}.${centiseconds.toString().padStart(2, '0')}`;
        }

        function getCurrentTime() {
            if (speedrunCompleted && completionTime) {
                return completionTime;
            }
            if (speedrunStartTime) {
                return Date.now() - speedrunStartTime;
            }
            return 0;
        }
        
        function gameLoop() {
            // Calculate delta time
            const currentTime = performance.now();
            const deltaTimeMs = currentTime - lastFrameTime;
            lastFrameTime = currentTime;

            // Normalize to 60 FPS (1.0 = running at exactly 60 FPS)
            const deltaTime = deltaTimeMs / targetFrameTime;

            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Update game
            updatePlayer(deltaTime);

            // Draw everything
            drawBackground();
            drawPlatforms();
            drawGoal();
            drawPlayer();
            drawUI();
            drawGameState();

            requestAnimationFrame(gameLoop);
        }
        
        // Event listeners
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' || e.code === 'KeyJ') {
                e.preventDefault();
                jump();
            }
            if (e.code === 'ArrowLeft' || e.code === 'KeyA') {
                e.preventDefault();
                keys.left = true;
            }
            if (e.code === 'ArrowRight' || e.code === 'KeyD') {
                e.preventDefault();
                keys.right = true;
            }
            if (e.code === 'KeyR') {
                resetSpeedrun();
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.code === 'ArrowLeft' || e.code === 'KeyA') {
                keys.left = false;
            }
            if (e.code === 'ArrowRight' || e.code === 'KeyD') {
                keys.right = false;
            }
        });
        
        canvas.addEventListener('click', jump);
        
        // Start game
        gameLoop();
    </script>
</body>
</html>
